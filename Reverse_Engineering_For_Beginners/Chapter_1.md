# Reverse Engineering For Beginners

## Code patterns

### 1.1 The method

The author of the book while learning C/C++ used to compile small snipets of his code and analyze the assembly. By doing this repetition he was able to envision what his programs would look like before he even compiled them.

The exercises he mentions in the book is to compile those small snipets of code and look at the assembly output and rewrite is gradually trying to make it as small as possible. You want to do this with zero compiler optimizer flags enabled. Thise flags will try and optimize both the performance and also the size of the code. The author also mentions this is not practical for writing efficient assembly compilers do this at a much fast and accurate rate than you can but it helps grasp the concepts of assembly and learn a lot. 

### 1.2 Some basics

This is a short i troductions to things like cpus and machine language type and jow numbers are representes on a computer. 

#### 1.2.1 A short introduction to the CPU

The CPU is what reads and executes the machine code given by a program. The suthor includes a small glossary of what words to know like instruction which is a primitive CPU command. Something like moving data from one place to another. Machine code which is the direct bits the CPU reads. Assembly language is next which just refers to mnemonic code to make the programmers life easier. There are a lot of sifferent type of assembky languages but they all have the goal of the level before machine code. Lastly CPU registers and the number of registers on different systems like an x86 or x86-64 system. Revisters are constantly X amount of untyped variables of length 32bits or 64bits. The author did a great job if explaining it as imagine you were peogramming in Java a high-level programming language and you had 16 variables and that was it. You can atill make any program even though you have only 16 variables. 

The author talks about different ISAs for assembly languges. Ppinting out the fact that instruction sets all have different lengths for their instructions. Some have variable insteuction lengths and other keep the max insteuction length to 4bytes some even as small as 2bytes. ISAa like ARM are kept at 4-bytes an instruction and the ISA Thumb is kept at 2-bytes. The creatirs of Thumb wanted to extend Thumbs capabilities so it could compete sith ISAs like ARM so they invented Thumb-2. Thumb-2 Is not a combination between ARM and Thumb rather it was meant to fully support all processor features. 

#### 1.2.2 Numeral Systems

Numeral system talks about the differences between base 10 and binary. Pointing out computers use binary and the number 10 has no use scientifically. The author also mentions radix's which are how many digits are in a number system. For example base 10 has radix 10 there are 10 different digits 0-9 to represent every number. Base 2 only has 0-1 two digits to represent every number. 

#### 1.2.3 Converting from one radix to another

Starting the author explains about positional notation and non-positional notation. Most numeric systems are ppaitional meaning the further to the left a number is the more significant it is. For instance the digit 1 has more weight in the number '100' than in the number '10'. The same goes for binary, the digit 1 in '0b1000' has more significance than '0b10'. This is how we are able to break down binary and base 10 numbers into sections for each digit. You can see this in the number 1234 is the same as 10^3 * 1 + 10^2 * 2 + 10^1 * 3 + 10^0 * 4. Each digit is multiplied by its radix to the power of its position minus one. 

Now representing these binary numbers are very verbose when you get into larger numbers or even just insteuctions. So we compress then into another numeric system base 16 or hexadecimal. We take our generic 0-9 and include 6 latin characters to represent numbers in hexadecimal. In most cases we will prefix our hexadecimal junbera with a 0x. There is another similar numeric system for computers and thats octal with is a base 8 numeric system with radix 8. 

The interesting thing about all numeric systems is that when you see a decimal number like 120 we know its divisible by 10. This same concept works for other sustems for example binary 0b11101000 is divisible by 0b1000. The same is true for both hex and octal 0x3cde210000 is divisible by 0x10000. 

For multi-precision integers the radix scales with the number of bits used to represent it. Basically if you have 8-bits per chunk your radix is 256 and if you have 32 bits your radix is 2^32 bits. 

### 1.3 An empty function

Arguable the simplest function ia one that does notiong or just returns. 

#### 1.3.1 x86

The assembly generated on an x86 platform is just a 'ret' instruction inside a 'f:' label. F being the function name. 

#### 1.3.2 ARM

On an ARM system the assembly is one line longer. This is because on ARM the return address is not stored on the atack but rather the link register. This requires you to use 'bx lr' causes execution to jump to that address effectively returning to the previous function before the adress was called. 

#### 1.3.3 MIPS

In MIPS assembly it ises a single j (jump) instruction followed by the register used in jumps. In GCC assembly you will often see the numeric value of the register and in an interactive disassembler like IDA or Ghidra you while see is pseudo name. 

#### 1.3.4 Empty functions in practice

It may seem like an empty function is meaningless but they are wuite popular eapecially in debugging. You will have debug function with #ifndef _DEBUG clauses for a prototype build. When you actually want to release the code for production you willnot include thise defines and will be left with an empty function. Similarly a build for customers and a build for demos. The other functions defined will be left empty. 

### 1.4 Returning values

Another simple function is one that returns a constant integer. 

#### 1.4.1 x86

In an x86 assembly system there are only two instructions. The first moves the value into the eax register which by convention hold return values. This first instruction is followed by the ret instruction. 

#### 1.4.2 ARM

Similar to x86 ARM by convention uses the r0 register for storing return values. It uses the mov instruction to do so. This might sound misleading because the value is not loved from one place but copied from one place to the next. This instruction is followed by the return instructions 'bx lr'. 

#### 1.4.3 MIPS

MIPS follows the same conventions as the others with a jump and a load with an 'li' instruction for load immediate. The odd factor in MIPS is that the jump is before the li instruction. What makes it interesting is the load instruction following the jump is executed before the jump. This is because of a quirk in the RISC called "branch delay slot". As a consequence to the jump preceding the load but executing after is that the branch instruction always swaps with the instruction immediately preceding it. 

### Hello world

The most famous C profram is most definitely the hello world program. 

#### 1.5.1 x86

The author compiled the program with MSVC 2010 and used the /Fa compiler flag to generate the assembly program. MSVC uses the Intel-syntax for assembly. In out case the assembly for the hello world file we have two segments one for the const (for constant data) and one for the text(code). Because while inline the steing "hello world" into the function it is jot givin a name. What we see in the const section of the program is that string, followed by a null character, with an auto generated name. Looking back at the code we only have one function which is out main() function. This function starts with prologue code and ends with epilogue code. This is stabdard for almost any function. After our prologue code we can see the call to the printf function, but before the function call we push the const char string onto the stack with push. Following the printf call is an add esp, 4. This is necessary because the pointer to the string is still on the stack so we need to add 4 bytes on a 32-bit system to do the equivalent of a pop on the stack. Some compulers might emit pop as an instruction but they are basically the same as adding the offset. The only difference is POP is 1 byte instruction and ADD is 3 bytes. After the printf the original C/C++ code contains return 0. This is a standard in C/C++ code where returning 0 ondicates no errors and anything else is a form of an error. In our assembky we accomplish this with xor eax, eax instruction again because eax is the standard return value and then ret. The reason it is xor not mov eax, 0 or sub eax, eax is because of the slightly smaller opcode. the opcase for xor is 1 whereas mov is 5 bytes. The ret in the case returns in function to the caller which in this case is the OS. 

The author compules the same C/C++ code with the GCC compuler so we can see how different compilers have different results. In the GCC compiler it strts similar woth the same epilogue code. This epilogue code has one different and that is it ANDs esp the stack register with 0FFFFFFF0h to alaign the stack pointer with the 16-byte boundary. This going back to that numeric division with different radixes. The reason we align the stack is for performance reasons on the CPU. The second difference is that the esp stack loint is subtracted by 10h 16 bytes which allocates 16 bytes if storage on the stack. Although 4 bytes are needed we still alocate 16-bytes because that is what we aligned out stack pointer with. After allocating soace on out stack instead of pushing values to the stack we store them directly onto the stack with a mov opcode. In this instance var_10 is a variable and an argument for printf(). Like we mentioned in MSVC the most optimal way to set a register to 0 is xor eax, eax. We do nit do this with the GCC compiler it opts for the mov eax, 0 instruction. This can be changed if we add optimization levels to our compile command. The last opcode leave is used to reset our stack pointer esp and ebp register. This is necessary because we mosified them at the start if our function. 

Previously we were working with Intel Syntax but now we are switching things up to work with AT&T assembly syntax. In the AT&T syntax we see a lot of macros being used in the program that we can ignore for now instead we want to just look at the opcodes being used. We can instantly see some differences like every register has a % prefix and every integer has a $ prefix. We can also see that unlike in Intel syntax where it is opcode, <destination operand>, <source operand> AT&T is switch with opcode <source operand>, <destination operand>. The third difference would be the size of an operand. There is a suffix added to the instruction; b for byte whoch is 8 bits, w for word which is 16 bits, l for long which is 32 bits, and lastly q for quad which is 4 words a quad word at 64 bits. The only difference from the AT&T syntax is the use of -16 as the and value which is synonymous to the and value used in intel syntx. 

We are able to instepct the bytes of a system in most hex editors. In most hex editors you can display the hex vakues alongside the ascii values. They most of the time give you the ability to change the values so we can potentially change the string being displayed in our hello world program. We could change the text into spanish if we really wanted like the author did and still emd the text with a 0A00 hex values for a new line character and a null character. Be carefull not to edit anything past what the original length is just because theyre are ann null bytes doesnt mean they are free to edit. 

We can do a similar thing in Linux using radare. We can strt by searching the program for the string. If we get a hit for the string we are looking for we can seek to move to that current address. With a combination of commands like px to print the binary and oo+ to open in read/write mode we can write with w followed by the string we want displayed instead. 

This ability to write over strings in executables has its place. One some images that have watermarks if you look through and found the string that the watermarks drew on the image you could replace it with spaces and the watermark would disappear. Another example the author mentions is translating program from english to russian. You coukd replace the English equivalents with russian acronyms as russian is slightly longer than english in word length. 

#### 1.5.2 x86-64

In x86-64 all registers were extended to 64-bits with all their names having an r prefix. In order to pass values to functions faster rather than use the stack meaning acces external memory/cashe less we can use the registers rcx, rdx, r8, and r9. These registers are known as fastcalls where part of the argumwnts the the function are passing in registers and the other in the stack. In our function we can see we use these registers specifically the rcx register to pass the pointer to the string into the printf function. x86-64 maintains backwards compatibility so you are still able to access the 32-bit part of a register. You can access all the following rax/eax/ax/al. This is important because in the main function we return the int 0 so we only need to xor the eax part of rax. Something the author will mw tion later is the 40 bytes alocated to the stack. 

The first program in x86-64 was compiled with MVSC and this one is compiled with GCC in 64-bit Linux. Any Linux, *BSD, and Mac OS X also use registers as arguments to functions. The first 6 registers rdi, rsi, rcx, rdx, r8, and r9 are all used and after those 6 we use the stack. In our profram we used the rdi register but only used the edi section of the register ti load the string pointer. We are able to do this because anytime we load or mov a value into the lower 32-bits it clears the upper 32-bits to all 0s automatically. The reason we assume GCC uses the 32-bit register edi instead of the 64-bit register rdi is because the instruction is 5 bytes long with edi and 7 bytes with rdi. We also see that the eax register is cleared right before the printf call. This is due to the ABI standards that the eax register is to hold the number of used vector registers on *NIX systems on x86-64. 

#### 1.5.3 ARM

When we first me tions differents ISAs ARM uses a fixed instruxtion size of 4-bytes. We can see this actually in the dissassembly of the hellow world program. The very first instruction STMFD SP!, {R4,LR} is the same as an x86 push by writing the two register values onto the stack. The instruction on the inside decrements the SP (stack pointer) so it points to the right place on the stack. The it loads the values in R4 and LR into the adress stored in the modified SP. The unique factor about STMFD is that it can save multiple addresses at once and is lot limited to the stack pointer. You can use the function to store registers at a specific memory address. The ADR R0, aHelloWorld instruction adds or subtracts the PC register to the offset where the hello workd string is located. This is called "position-independant-code" where the program can be ran at a non-fixed address. The code takes into account where the PC address currently is and where the string is located in the program. subtracts to get the difference. This difference is always the same so this offset is what we always add to the PC in order to get the absolute memory address of the string. The BL _2printf is what called the printf function. We store the address following the BL instruction into the LR register and the set the PC to the address of printf(). In ARM each function needs information about where it needs to return to thats why we pass the following addres to the function call into the LR register. This is the difference between RISC processirs with ARM and CISC processors with x86 where ARM stores the return address in lr and x86 stores it on the stack. A side note is that absolute return addresses cannot be encoded in the BL instruction because the instruction is 1 byte so we are left with 3 bytes or 24 bits for the address. We can increase this number to 26 bits when we take into account that ARM instructions are all 4-bytes long. He ce, they can only be on a 4-byte boundary implying the last two bits are always 0s. This gives us that 26 bits for addressing which is approximately 32M addresses. Next our function moves 0 into register R0 because our C function returns 0. The last opcode LDMFD DP!, R4,PC works just like a pop on the stack. Remember back to the start of the program when we saved LR onto the stack with STMFP. Well this basically loads the LR return value into the PC so we can pass control to where the function was called. All of this code was compile in ARM mode the next section covers Thumb mode. 

Thumb mode is effectivly a compressed version of the ARM mode. Each instruction is 2 bytes long except the BL opcode is separated into two instructions. This is because there is not enough space in the 16-bit opcode so it splits the first 10-bits into the first instruction and the lower 11 in the second. Thumb instruction have a size of 2 bytes so it is impossibke to have an odd address. With this in mind we have 21 bits plus the 22nd bit which is garunteed to be 0 equaling approximately 2M of adressing space. Thumb ARM also includes the PUSH and POP opcodes and do not explicitly mention the SP register. 

When compiling with Xcode without optimizations produces a lot of redundant code to the author opts to set the optimization flag to -03 when compiling. This is compuled in ARM mode so when we look at the assembky we see the familiar STMFD and LDMFD instructions like before. After the STMFD we move the value 0x1686 into register R0. This constant value is the offset pointing to the string. The R7 register is the standardized frame pointer in iOS function call guide. (explain more once read). The MOVT R0, #0 instruction is to move 0 in the top 16-bits of the register. This is because the generic MOV instruction can only set the lower 16-bits. The instruction in out code is however redundant because the previous MOV instruction already cleared the too 16-bits so it is not necessary to set them all to 0. The ADD R0, PC, R0 is an important insteuction for getting the value of where the string is stored. This is because the Value stored in R0 is just the offset and with this being position independant code we need the PC to know where the program is at and add the offset to get the true position. With the optimizations in mind we see that the BL instruction calls puts instead of printf this is presumably because puts is faster. It directly prints to stdout rather than compare each character to a %. Last instruction is the very familiar Mov R0, #0 for returning. 

We are not going to take a look at the Thumb-2 mode with Xcode compilation. Most of th start is similar woth w Push opcode but the BL and BLX opcodes are special in Thumb-2 because they can handle 32-bit instruction. The original Thumb supported BL and BLX with two 16-bit instructions however in the upgraded Thumb-2 we have the 4-byte instructions and can represent BL and BLX as single instructions. Something we need to take into account while reading the hez of the instructions from intel vs arm is the endianess. In the instructions for the BL and BLX they always start with the hex values 0xFx or 0xEx so when we read the code we expect to read left to right for our hex values. This is a little off because when we look at the code the hex looks backwards and this is because of endianess. Back to the topic of the program the next instruction is similar and adds the strings offset into the R0 register with a MOVW, W being a word which is 16-bits. This instruction is followed by the same MOVT.W in R0 to set it to 0. The different from BL and BLX is that the RA and LR registers are saved to pass control to puts but the processor is also switching from Thumb/Thumb-2 mode to ARM mode or vice verse. The way im understanding is that the call to BLX is used for external libraries because it jumps and sets the instruction to some ARM encoded instructions that point to the address of puts in the import section. This is because we use dynamic libraries to save soace in programs so it calls the function puts from where it is located on the system. The way it works is that the executable binary files loads all the files that a linked and puts them in an inport section with the imported modules (mostly functions or global variables) and the names of the modules. This way it has the addresses and can just set the address of the PC run the function and return. We alresdy know its impossible to set an address value of 32-bits though so instead what we do is allocate a function dedicated to passing control to the dynamic library. This will reauire switching to ARM to use 32-bit addresses and returning and switching back to Thumb/Thumb-2. These function we are jumping to pass control are short one-instruction functions called thunk functions. Now that we know this information we can learn that in the precious compuled code in ARM mode we called the same thunk function but we weren't switching modes so there is the absence of the X in BLX. 

Side Note: In my personal experience ive reverse engineered system that have thunk functions and have always wodndered their purpose. 

The author describes thunk functions as the connectors or adapters for programs. They are used to connect 16-bit and 32-bit programs together. They are also considered wrappers for the functions a great example would be using old FORTRAN libraries or packages in your C/C++ code. We can call these short C/C++ function callable in a C/C++ environment capable of calling the FORTRAN function. 

We now move onto ARM64 compuked in GCC. In ARM64 there is no longer any Thumb/Thumb-2 modes there is only ARM mode. This means there are 32-bit instructions only. Included woth ARM64 the amount of registers have doubled and are 64-bits in size. Similar to x86-64 with the r prefix and e prefix ARM64 uses the x prefix for its 64-bit register and w for its 32-bit parts of a register. The program started with an stp x29, x30, [sp,#-16]!. The initial instruction being set is a store pair instruction which stores two values simultaneously. This can be used to store values elsewhere but we defined on the stack with out so in the brackets. this is followed by #-16 which is the amount of bytes we want to allocate to the stack. We do this by subtracting that many bytes, 8 for each 64-bit register. You might've noticed the ending ! this is called a pre-index ensures that the stack pointer is set before any values are initialized. In ARM64 the sto is equivalent to the push of x29 and push x30. They are the same because the x29 register is the standard FP is ARM64 and x30 is the standard LR in ARM64. That is why they are saved in the function prologue and restored in the epilogue. Because the instruction size is limited to 4 bytes there is no way to atore large numbers in registers without multiple instructions. This is why we split it into the ADRP call and ADD. The ADRP instruction gives us the address of the 4KiB page the string is located at. This returns the start of the page so we use the add to add the addition byte offset to get to our string. We next do a function call to puts with our BL instruction and set our x0 register to zero with a mov w0, #0x0. Why is it using the 32-bit part? That is because ints are 4-bytes long or 32-bits so we only need to set the lower half to 0 and return that value. The author shows thia concept of retuening 32 bits by changing the return type to a u_int64 for the main function. This changes the assembly to use the mov x0, 0x0 which is the 64-bit register. After we move the value into register x0 we run the instruction LDP load pair without the pre-index. This means we load the two values off the stack and then after they have been loaded we a 16 bytes to the stack pointer. Finally returning using a ret instruction whoch is new in ARM64 and works the same as a BL call just is optimized so the program knows its not a notmal just but a return from a function. 

#### 1.5.4 MIPS

The important concept in MIPS is the global pointer. MIPS has instruction sizes of 32-bits so it is impossible to load 32-bit instruction sizes into registers without two instructions. It is possible however to load data from the register wing a signed 16-bit range. The global pointer accomplishes this exact purpose. The global pointer sits in the middle of the allocated 64KiB area which contains mainly global variables and function addresses. The GCC developers decided getting function addresses needed to be a one instruction instead of two. This leads us to the .sbss and .sdata sections for small uninitialized data and small initialized data. In the epilogue of the assembly we see lui to load effectively the page of the middle address. Next we go theough our addiu instructions to allocate 32 bytes on the stack and add the page offset to the gp. We start by aaving our return address to the local stack. After we save the return address we load the address of the puts function from out gp refister onto our $25 register. Next we load the address of our text into the $4 register. Once we have loaded our atrinf we jump to the puts function. Remember! MIPS has the branch delay so our addiu instruction is after our initial jump instruction. We need to add the lower offset to out string then the jump initiates. After returning we restore the RA in register $31, and set register $v0 to zero. Once the return value has been set we jump to the return address and restore out stack pointer as the branch delay slot of that jump. An important note is the jump to pits() is a jalr just which sets the value of RA to the next address to return to after the function call. Remeber this is not the next address cause that is out branch delay slot but the next next instruction. We also use the register $0 which is MIPS is just the constant 0. Another interesting fact the author mentions is that the MIPS doesnt have an opcode for moving register values instead it is MOV DST, SRC is actually ADD DST, SRC, $ZERO setting the destination to the source. The author assumes that the CPU does it's own optimization on this instruction behind the scenes. In the IDA listing there a couple points to note and that is the register holding the puts function address is prefixed with a t for a temporary register. The gp registser is also saved in the local stack in the IDA list which the author statea could be a GCC error. 

The unoptimized version of the GCC code has a few more verbose attributes like the use of the $fp register which is the stack from pointer. Also in the verbose version after jumps there are nop instructions. The author assumes that this is the case that all jumos are followed by a nop to deal with the branch delay. Something interesting about the IDA version is that loading the go register was coalesced into a la load address pseudo instruction. This pseudo instruction is 8 bytes in size and also known as a macro. It is a macro because it is not a real MIPS instruction rather a handy name for a pair of instructions. Something IDA does not recognize is nops. Instead it replaces them with a meaningless inateuction like ORing a register with the zero register. Something else in the unoptimized version is that the stack frame was setup but we didn't use it for saving the string before the puts call. Instead we saved it in a register. What is the purpose of the stack then? The purpose is to save the RA and GP registers on the stack because we are calling printf() we need to save them somewhere.

#### 1.5.5 Conclusion

The main difference between more legacy version like x86/ARM and x64/ARM64 is that pointers are 64-bits long. With the modern demand for more memory and storage 32-bit memory addresses cannot address enough space. As such all pointers are now 64-bits.

#### 1.5.6 Exercises

##### Exercise 48
This function pushes 0xFFFFFFFF onto the stack and calls MessageBeep. After the MessageBeep we xor register eax and return the function and give control back to the caller. I am not sure why it pushes 0xFFFFFFFF onto the stack but I would assume that this is a required parameter for the MessageBeep function. 

##### Exercise 49

This Linux function starts by storing the base of the stack onto the stack. This saves the previous stacks base pointer so we can initialize a new stack. We do this by setting the new base pointer to the address of the stack pointer. This is AT&T syntax to it is mnemonic src, dst. The next instruction is setting the parameter of the sleep function we are about to call to two seconds, then we call the sleep function. After the function returns we pop the original base pointer off the stack and return control to the caller.

### 1.6 Function prologue and epilogue

A function prologue is the sequence of instruction at the stat of a program. It often starts with the same set of instructions which start by pushing the stack base pointer onto the stack. After you pass the base pointer onto the stack you set the new base pointer as the end of the stack. Following loading the new base pointer we allocate room on the stack with a sub instruction. The function epilogue does the oposite as the prologue. It frees the space allocated at the start of the function, resets the base pointer to the original value, and returns control to the caller.

#### 1.6.1 Recursion

Function epilogues and prologues can negatively effect recursion the author says.

### 1.7 An empty function: redux

If we go back to the empty function example and we turn off optimization we can see our generic function prologue and epiloge. In the middle of the two is a single nop instruction. By looking at this function the really only important instruction is the ret instruction all the others are pointless. There is no need to set a new bp and reset it if there is not goin to be any stack allocations and we just have a nop which is literally no operation.

### 1.8 Returning values: redux

A similar situation happens when we go back to the returning a single value functions. If not compiled with optimizations there is no need for the function prologue and epilogue. The only important instructions are the mov and the ret.

### 1.9 Stack

One of the most fundamental data structures in computer science is the stack. Technically it is just a block of memory that we push and pop values off of and have a register which points to the top. Hint the two most commonly used stack access instructions are the push and pop which add or subtract 4 bytes in 32-bit architextures or 8 bytes in 64-bit ones. Push adds the data to the stack which is wy we add the bytes for allocation and pop subtracts the bytes to free the data and move it into the disignated register. After we allocate space for the stack the stack pointer points to the bottom of the stack. This means that push decreases the stack pointer and pop increases it. The bottom of the stack is actually at the beginning of the memory. ARM is the exception cause it supports both ascending and descending. If you remember the STMFD/LDMFD the D post-fix stands for descending. There are other instruction STMFA and LMDFA which are for ascending stacks.

#### 1.9.1 Why does the stack grow backwards

The author explains this is probably for historical reasons. Back when the stack and the heap had very little memory to use it was hard to split the amount of memory because you never knew exactly how much memory the stack was going to use or the heap was going to use. The solution the Heap would grow up starting at the first address and the stack would grow does starting at the final address. This means the grow into each other taking as much space as the need. The author relates it to writing two classes notes in a single notebook. You start lecture notes for one class in the fron tof the notebook and you write the other class's notes from the back to the front. You keep doing this until your notes run into each other.

#### 1.9.2 What is the stack used for

The most common use of the stack would be for holding the return address when a function is called. The return address being the instruction after the call address. The ret instruction simple grabs the value off of the stack and returns to the correct address. This is equivalent to a push address after the call and then a jump instruction to the address we want to call. When it is ready to return it is similar to poping the return address into a temp variable and jumping to that return address. Call and Ret do this implicitly. Overflowing a stack is pretty straightforward. You need to run an infinite recursion such as calling a function inside of itself with no return. When you compile most compilers will warn about this and even tell you there will be a stack overflow and still generate the code. What is insteresting about the unoptimized vs optimized code is that the optimized code never gets a stack overflow. The assembly it generates doesn't have the prologue or epilogue so there is no allocations to the stack. It also doesnt call the function like it does int he unoptomized version. Instead it creates a label at the beggining of the function and just repeatedly jumps back up to the label.

ARM also uses the stack for return addresses but differently. It is slightly different because if we remember back in ARM we save the return address in the LR link register. When we save the value onto the stack is when we know we are going to call another function and change the value of the LR. The times we do not save the return address on the stack is when we have a function that does not call another function. Tis is called a leaf function in ARM. These functions can potentially be small enough to only use a few registers and not require the stack. This can be usefull when memory for the stack is not allocated yet or is not available.

Passing function arguents is another popular way to use the stack. The most popular way to pass parameters in x86 being 'cdecl'. These are callee functions and get their arguments via the stack pointer. You would push your arduments from last to first and then call the function. These callee functions do not have any information about how many arguments were passed. These callee functions are primarily used for functions with variable inputs like the printf function or your main function in C. C functions like printf use their formatted string to determine the number of arguments to read off of the stack. Something important is it does not pop values it reads them using the stack pointer. This means that if out formatted string is "%d %d %d" and we only give it one input 1234, the other two vlaues will be random numbers read off the stack. This explains why it is not very important that we declare them in our main function or how we decalre them. In main if you decide to not declare any of the arguments they will still be there on the stack but you will just not have access to them. The ones you do not decide to use will just remain "invisible".

There are alternative ways of passing arguments. It is not required for you to pass arguments through the stack. A lot of assembky beginners will use global variables. These global variables have obvious issues like the function not being able to call itself. If it is using the variables in one instance you call another it has to zap those values. The same thing happens if you store local variables into global ones you can't call your function inside of itself. These are also not thread safe. MS-DOS had a way of passing function arguments through registers. It is very similar to a system call in Linux or Windows. 

Functions can allocate space for their local variables on the stack by decreasing the stack pointer. This explains why it is very fast no matter the number of local variables you define. This can technically be done anywhere but bu convention it is done in the stack. 

In x86 there is a function alloca() that works very similar to malloc() but allocates the memory directly to the stack. The memory allocated this was does not need to be freed. We know this because after the function in the function epilogue restores the stack sk there is no need for us to free it. When we compile a program is both GCC and MVSC we can see in the MVSC version it does a call to the alloca function and puts the argument into the eax register. In GCC it does the allocation already in the same function. After to prologue it subtracts 660 bytes from the stack pointer. I assume what is happening is it add 60 bytes to the 60 it was already going to allocate for local variables. 

One if the main reasons that local variables might prefer to be allocated to the stack is the data is freed on exit. You can use a single insteuction to correct the stack. Function arguments are also deallocated automatically at the end of the function. In contrast the heap needs to be deallocated explicitly. 

